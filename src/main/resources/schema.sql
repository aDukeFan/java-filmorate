
DROP TABLE IF EXISTS
users, follows, ratings,
genres, films, likes,
genres_films, directors, directors_films, reviews, reviews_rates, events CASCADE;

DROP index if exists index_follows_id;
DROP index if exists index_likes_id;
DROP index if exists index_genres_id;
DROP index if exists index_directors_id;
DROP index if exists index_rewiews_rates_id;


create table if not exists users (
id integer generated by default as identity not null primary key,
name varchar(255),
email varchar(255) not null,
login varchar(255) not null,
birthday date
);

CREATE TABLE if not exists follows (
    following_id integer not null references users(id) on delete cascade,
    followed_id integer not null references users(id) on delete cascade
);

create table if not exists ratings (
id integer generated by default as identity not null primary key,
name varchar(200) not null unique
);

create table if not exists genres (
id integer generated by default as identity not null primary key,
name varchar (200) not null unique
);

create table if not exists films (
id integer generated by default as identity not null primary key,
name varchar(200),
description varchar(200),
release date,
duration integer not null,
rating_id integer, foreign key (rating_id) references ratings(id)
);

CREATE TABLE if not exists likes (
  film_id integer not null references films(id) on delete cascade,
  user_id integer not null references users(id) on delete cascade
);

CREATE TABLE if not exists genres_films (
    genre_id integer not null references genres(id) on delete cascade,
    film_id integer not null references films(id) on delete cascade
);

create table if not exists directors (
id integer generated by default as identity not null primary key,
name varchar(200) not null
);

create table if not exists directors_films (
director_id integer not null references directors(id) on delete cascade,
film_id integer not null references films(id) on delete cascade
);

create table if not exists reviews (
id integer generated by default as identity not null primary key,
content varchar,
is_positive boolean,
user_id integer not null references users(id) on delete cascade,
film_id integer not null references films(id) on delete cascade
);

create table if not exists reviews_rates (
review_id integer not null references reviews(id) on delete cascade,
user_id integer not null references users(id),
useful integer
);

create table if not exists events (
event_id integer generated by default as identity not null primary key,
event_timestamp timestamp,
user_id integer not null references users(id) on delete cascade,
event_type varchar(30) not null,
operation varchar(30) not null,
entity_id integer not null
);

create index if not exists index_follows_id on follows (following_id);
create index if not exists index_likes_id on likes (film_id);
create index if not exists index_genres_id on genres_films (genre_id);
create index if not exists index_directors_id on directors_films (director_id);
create index if not exists index_rewiews_rates_id on reviews_rates (review_id);

-- не создавали индексы там, где есть primary key, так как при создании pk уже неявно создается кластеризованный
-- индекс и сортировка данных таблицы идет по pk, поэтому индексы созданы по внешним ключам таблиц, где не создан pk




